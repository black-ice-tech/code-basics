# Lesson #2 - Git and GitHub
## Overview
Git is a version control system (VCS) that allows you to manage your code and collaborate with others. Git resources:
- https://www.atlassian.com/git
- https://try.github.io/
- https://www.elegantthemes.com/blog/resources/git-and-github-a-beginners-guide-for-complete-newbies

We won't go into too much detail in this lesson, so those resources above are highly recommended if you want a deeper understanding of how Git and GitHub work.

## Creating a Git repository
Open up Git Bash (or your terminal of choice), and navigate to the directory from lesson #1 (probably `hello-world`). Once you are there, run the following command:
```bash
git init
```
This will initialize a Git repository in the folder you are currently in. Now run:
```bash
ls -a
```
This command lists the files and directories in your current directory AND includes hidden files and directories (those that begin with a "."). You'll notice there is a new directory `.git`. This contains config info and other git related things. You shouldn't need to worry too much about the contents of this directory. Just know that when you create a repository, this folder will also be created.

Now you have a repository created! Great, now lets create a GitHub repository, so that you can store your code on GitHub rather than on your computer. Go into GitHub, and create a new repository through the UI.
```
TODO: add screenshots
```
After you create your repository, you'll see 2 options, one says
"…or create a new repository on the command line" and another says "…or push an existing repository from the command line". Since you've already created your repository locally, you want the second option. But first, let's create a `README.md` in your repository (this is recommended to exist in every git repository). Run the following command:
```bash
echo "# Hello World" >> README.md
```
This puts the text "# Hello World" into a new file "README.md". ".md" is a markdown file, which allows certain things (such as GitHub) to display the file in a particular way. For example, the "#" indicates a large header style. For more info on markdown formatting, [here](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) is a cheatsheet. 


Now you have a README, let's commit that file and put it in your GitHub repository.
```bash
git add README.md
```
This file is now "staged', i.e. it's marked to be committed. Now commit your changes:
```bash
git commit -m "Initial commit"
```
At this point, you have a commit sitting in your *local* copy of your repository. Now we need to **push** the changes to GitHub (your remote repository).
```bash
git remote add origin https://github.com/<your_username>/<your_repo_name>.git
git push origin master
```
"origin" means the remote repository, in this case it is in GitHub. "master" is the branch. Every repository, by default, has a "master" branch. More to come on branches later.

At this point, you should now be able to see your code in your GitHub repository. If you still see the page with the options for commands, something went wrong, feel free to reach out for help. It may ask you to set your username and email. Go ahead and follow the instructions to do so (you can always change these).

## Pulling code
If you are using Git Bash, you will have, parentheses around your branch name, to the right of your current directory. In this case, since we haven't created any new branches yet, it will say `(master)`. Now let's go into GitHub and add a new file. 
```
It is almost always a bad idea to create files directly in GitHub. However, this is an exception so that we can demonstrate how a "pull" command works.
```
In your repository main page, there should be a button "Create new file". Click that, and name the file `.gitignore`. Copy and paste the following contents into it:
```
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUNIT
*.VisualState.xml
TestResult.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/
**/Properties/launchSettings.json

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_i.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# JustCode is a .NET coding add-in
.JustCode

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk 
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# JetBrains Rider
.idea/
*.sln.iml

# CodeRush
.cr/

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output 
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder 
.mfractor/
```
Don't worry too much about the contents of this file. Just know that it is telling Git which files to ignore when tracking changes. For example, user specific files, compiled files, IDE settings, etc. If you are interested in learning more about `.gitignore` files, take a look [here](https://www.atlassian.com/git/tutorials/saving-changes/gitignore).

Now that you've added a new file into your remote repository, you can `pull` the latest changes from the repository into your local copy. 
```bash
git pull
```
You should see some output that indicates you pulled a new file.
Now run:
```bash
ls -a
```
This lists all files / directories, including hidden ones (ones that begin with a "."). You should see the `.gitignore` file you added in GitHub in your local copy now. 

## Branches
Currently you are on branch `master`, and now you want to work on a different feature for the HelloWorld project. Your feature is addressing the feedback from the first lesson. Let's create a branch to reflect that:
```bash
git checkout -b feature/feedback
```
This is doing a couple of things, 1) it's creating a new branch called `feature/feedback` based off of `master`, 2) it's **checking out** the newly created branch. So now, you should see `(feature/feedback)` in Git Bash.

A branch is a way to isolate the code changes you are working on. The common practice when using GitHub to getting your branch back into `master` is called a **pull request**, and we'll go into that in the next section.

## Pull requests and code reviews
After you have implemented the feedback you received from your instructor, we can now push your branch to GitHub.
```bash
git add -A # this adds all changed files locally
git commit -m "Implement feedback"
git push origin feature/feedback
```
Look in GitHub, and you should see a yellow banner near the top that shows your new branch. Go ahead and click "Compare & Pull Request" and the right of the banner. Name your pull request (PR from here on) something meaningful, and add in the description the changes you made. Be descriptive, but concise. In the top right, you'll see "Reviewers", click the dropdown and add your instructor. Next, scroll down and double check that your code changes are as you expect them to be (green means code that is added, red is code that is removed). Then when you are ready, click "Create Pull Request". 

At this point, your instructor can review your code and make comments on it. He may ask you to make some changes, and if so, you can make changes using the exact same commands as above, with the only difference being the commit message. Once your code is ready, you instructor will merge it, which will put your changes from your branch back into the `master` branch. 

From here on out, this is how we will be submitting code throughout this course. It's also extremely common practice in GitHub, so these skills will carry over into pretty much any software job.

## Tips and tricks
1) Never merge directly into `master`. In the real world, sometimes people do this by mistake and wreak havoc on their systems. It is always best practice to create a branch for your work, and submit a PR (and have it reviewed by other team members) for it to be merged.
2) Use good Git commit message hygiene, see [here](https://chris.beams.io/posts/git-commit/)
3) Download a GUI tool once you get the hang of the commands and what the do. I recommend [Source Tree](https://www.sourcetreeapp.com/)

